# 第2章-1：バージョン管理システムの基本概念

## 🔧 CI/CDの技術的基盤へ

第1章では、CI/CDの根本的使命と現代ソフトウェア開発が直面する課題について見てきました。第2章では、これらの課題を解決するCI/CDを**実際に実装するための技術的基盤**について学んでいきます。

## はじめに：なぜバージョン管理システムから始めるのか

CI/CDという現代的な開発手法を理解する上で、前提となるのが「ソースコードをどのように管理するか」です。バージョン管理システムは、CI/CDパイプラインの出発点であり、**自動化・テスト・デプロイといった全てのプロセスが「コードの変更」をトリガーに始まる**という点で不可欠な役割を担います。本章では、CI/CDの文脈を意識しながら、バージョン管理システムの基礎を丁寧に解説します。

---

## バージョン管理システムとは？

### 定義と基本概念

\*\*バージョン管理システム（VCS: Version Control System）\*\*は、ファイルの変更履歴を記録・管理し、過去の状態に戻したり、変更内容を追跡したりできる仕組みです。

```
バージョン管理なしの開発:
project_v1.py
project_v2.py
project_v2_fix.py
project_v2_fix_final.py
project_v2_fix_final_really_final.py
↓
混乱、重複、履歴不明

バージョン管理ありの開発:
project.py (常に最新版)
├── v1.0: 初期リリース
├── v1.1: バグ修正
├── v2.0: 新機能追加
└── v2.1: パフォーマンス改善
↓
明確な履歴、安全な変更管理
```

### 現代ソフトウェア開発におけるバージョン管理の必要性

#### 開発規模の拡大

開発形態は、個人開発からチーム、さらには大規模組織へと進化しています。ファイル数・変更頻度も比例して増加し、手動での管理では追いつかなくなりました。

```
開発体制:
個人 → チーム(5-10人) → 組織(100人以上)

管理対象:
ファイル数: 10個 → 100個 → 数万
変更頻度: 週1 → 日10回 → 分単位
```

バージョン管理は、そうした複雑さに秩序をもたらし、チームでの共同作業を可能にします。

#### 開発サイクルの高速化

ウォーターフォールからアジャイルへと開発手法が変化したことで、変更頻度やリリース速度が飛躍的に上昇しました。

```
旧来:
計画(数ヶ月) → 開発 → テスト → リリース(年数回)

現在:
計画(1週) → 開発(継続) → テスト(継続) → リリース(週次〜日次)
```

この変化に対応するには、変更の正確な記録と追跡が必須です。バージョン管理はその土台となります。

---

## バージョン管理システムの価値

### 1. 変更履歴の明確な記録

#### Who（誰が）

* **責任の明確化**: 各変更の責任者を追跡することで、問題発生時の迅速な対応が可能になります。
* **知識の継承**: 実装者の意図を残すことで、後続メンバーが背景を理解した上で改修できます。
* **学習機会の創出**: 他メンバーの実装から学ぶことで、チーム全体の技術力向上にもつながります。

#### When（いつ）

* **変更タイミングの記録**: バグの発生時期と変更履歴を突き合わせて原因を絞り込みます。
* **リリースごとのスナップショット**: 特定の状態を明示的に管理することで、後からでもその時点を再現可能です。
* **時系列分析**: 変更の傾向やスピード感を把握し、プロジェクトの健康状態を測ることができます。

#### What（何を）

* **詳細な差分追跡**: 行単位の差分により、どの部分がどう変わったかを一目で把握できます。
* **影響範囲の推定**: 変更対象の関連コードに波及する影響を分析できます。
* **レビュー支援**: 差分ベースでレビューできるため、効率的かつ正確なコードチェックが可能です。

#### Why（なぜ）

* **背景の記録**: コミットメッセージにより、なぜその変更が必要だったかを明文化します。
* **意思決定の継承**: 設計判断やアーキテクチャ選定の理由を記録に残すことで、過去の文脈が読み取れます。
* **仕様との整合性**: どのビジネス要件に紐づく変更かを明確にすることで、開発の目的がブレません。

### 2. 安全な実験環境

#### ブランチ

* **並行開発の実現**: 複数人・複数機能の同時開発を安全に進められます。
* **隔離された検証**: 本番コードに影響を与えず、自由な試行錯誤が可能です。
* **段階的統合**: 安定した状態でのみ本流にマージすることで、品質と速度を両立できます。

#### マージ

* **競合検出と通知**: 自動で衝突を検出してアラートを出すため、見落としを防げます。
* **手動解決サポート**: 衝突箇所を視覚的に表示し、解決を支援します。
* **統合テストの起点**: マージ時に自動テストを走らせることで、品質を確保します。

#### ロールバック

* **即時復旧**: 想定外のバグが出た際に、前の安定状態へ即座に戻せます。
* **選択的リバート**: 問題のある変更だけをピンポイントで巻き戻すことも可能です。
* **復旧履歴の保持**: ロールバック操作自体も記録されるため、対応の透明性が確保されます。

### 3. チーム協調の基盤

#### 並行開発

* **タスクの分担**: 大きな機能を複数人で分担して並列に進行できます。
* **独立性の担保**: 他人の作業に左右されずに自分のタスクを遂行できます。
* **進捗共有**: 誰がどの作業をしているかをチームで把握しやすくなります。

#### 競合解決

* **非破壊的統合**: 複数人が同じファイルを変更しても、安全に統合できます。
* **視覚的な差分表示**: コンフリクト部分を明示的に確認し、適切な選択ができます。
* **意思決定の記録**: 解決の過程も履歴として残すことで、再発防止にも活かせます。

#### レビュー機能

* **コード品質の担保**: 本番反映前に他者レビューを挟むことで、ミスを減らします。
* **知識の共有**: コメントやフィードバックを通じて、チーム内の学習機会が増えます。
* **基準の統一**: コーディング規約や設計指針の共通理解を醸成できます。

---

## バージョン管理システムの歴史と進化

### 第1世代：ローカルVCS（1970s〜1980s）

* RCSなど。単一ファイルをローカルで管理。
* チーム開発には不向き。

### 第2世代：集中型VCS（1990s〜2000s）

* CVS、Subversion（SVN）など。
* 中央サーバーで一元管理。ネットワーク依存。

### 第3世代：分散型VCS（2000s〜）

* Git、Mercurialなど。
* 開発者全員が完全な履歴を保持。オフラインでも作業可能。

---

## 集中型 vs 分散型

| 項目      | 集中型（SVNなど） | 分散型（Gitなど）     |
| ------- | ---------- | -------------- |
| アーキテクチャ | 中央サーバー型    | 各クライアントが完全なコピー |
| オフライン作業 | 不可         | 可能             |
| ブランチ作成  | 重い         | 軽量・高速          |
| マージ操作   | 複雑         | 高度なマージ機能       |
| 学習コスト   | 低い         | やや高い           |

---

## まとめ

バージョン管理システムは、現代の高速・大規模な開発において、変更の正確な記録・共有・復元を可能にし、リスクを最小化しながら品質を高めるための基盤です。そしてこれはCI/CDのスタート地点としても機能します。次章では、その代表格であるGitの基本操作と活用法を紹介していきます。
